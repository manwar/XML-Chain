NAME

    XML::Chain - chained way of manipulating and inspecting XML documents

SYNOPSIS

        use XML::Chain qw(xc);
    
        # basics
        my $div = xc('div', class => 'pretty')
                    ->c('h1')->t('hello')
                    ->up
                    ->c('p', class => 'intro')->t('world!');
        say $div->as_string;
        # <div class="pretty"><h1>hello</h1><p class="intro">world!</p></div>

DESCRIPTION

    ☢ at this moment XML::Chain is in early prototype phase ☢

    This module provides fast and easy way to create and manipulate XML
    elements via set of chained method calls.

EXPORTS

 xc

    Exported factory method creating new XML::Chain::Selector object with a
    document element as provided in parameters. For example:

        my $icon = xc('i', class => 'icon-download icon-white');
        # <i class="icon-download icon-white"/>

    See "c, append_and_current" in XML::Chain::Selector for the element
    parameter description and "CHAINED METHODS" in XML::Chain::Selector for
    methods of returned object.

  xc($name, @attrs) scalar with 1+ arguments

    Element with $name will be create as document element and  @attrs  will
    be added to it in the same order.

    In case of hash reference passed as argument, key + values will be set
    as attributes, in alphabetical sorted key name order.

  xc($xml_libxml_ref)

    In case of XML::LibXML, it will be set as document element.

  xc($what_ref)

    Any other reference will be passed to "slurp($what)" in IO::Any which
    will be then parsed by "load_xml" in XML::LibXML and result set as
    document element.

        say xc([$tmp_dir, 't01.xml'])->as_string
        say xc(\'<body><h1>and</h1><h1>head</h1></body>')
                ->find('//h1')->count

  xc($scalar)

    Element with $scalar will be create as document element.

        say xc('body');

CHAINED METHODS, METHODS and ELEMENT METHODS

    See XML::Chain::Selector and XML::Chain::Element.

CHAINED DOCUMENT METHODS

        xc('body')->t('save me')->set_io_any([$tmp_dir, 't01.xml'])->store;
        # $tmp_dir/t01.xml file no consists of:
            <body>save me</body>
        xc([$tmp_dir, 't01.xml'])->empty->c('div')->t('updated')->store;
        # $tmp_dir/t01.xml file no consists of:
            <body><div>updated</div></body>

 set_io_any

    Store  $what  of IO::Any for future use with  -store() >

 store

    Calls  IO::Any-spew($io_any, $self->as_string, {atomic => 1}) > to save
    XML back it it's original file of the the target set via set_io_any.

TODO

        - partial/special tidy (on elements inside xml)
        - per ->data() storage
        - setting and handling namespaces and elements with ns prefixes
        - ~ton of selectors and manipulators to be added

CONTRIBUTORS & CREDITS

    Initially inspired by Strophe.Builder, then also by jQuery.

    The following people have contributed to the XML::Chain by committing
    their code, sending patches, reporting bugs, asking questions,
    suggesting useful advice, nitpicking, chatting on IRC or commenting on
    my blog (in no particular order):

        Mohammad S Anwar
        you?

    Also thanks to my current day-job-employer http://geizhals.at/.

BUGS

    Please report any bugs or feature requests via
    https://github.com/meon/XML-Chain/issues.

AUTHOR

    Jozef Kutej

COPYRIGHT & LICENSE

    Copyright 2017 Jozef Kutej, all rights reserved.

    This program is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

